import { readFile } from 'node:fs/promises';
import * as xlsx from 'xlsx';

import type { DocumentPage, FileLoaderInterface } from '../../types';

/**
 * Converts sheet data (array of objects) to a Markdown table string.
 * Handles empty sheets and escapes pipe characters.
 */
function sheetToMarkdownTable(jsonData: Record<string, any>[]): string {
  if (!jsonData || jsonData.length === 0) {
    return '*Sheet is empty or contains no data.*';
  }

  // Ensure all rows have the same keys based on the first row, handle potentially sparse data
  const headers = Object.keys(jsonData[0] || {});
  if (headers.length === 0) {
    return '*Sheet has headers but no data.*';
  }

  const headerRow = `| ${headers.join(' | ')} |`;
  const separatorRow = `| ${headers.map(() => '---').join(' | ')} |`;

  const dataRows = jsonData
    .map((row) => {
      const cells = headers.map((header) => {
        const value = row[header];
        // Handle null/undefined and escape pipe characters within cells
        const cellContent =
          value === null || value === undefined ? '' : String(value).replaceAll('|', '\\|');
        return cellContent.trim(); // Trim whitespace from cells
      });
      return `| ${cells.join(' | ')} |`;
    })
    .join('\n');

  return `${headerRow}\n${separatorRow}\n${dataRows}`;
}

/**
 * Loads Excel files (.xlsx, .xls) using the 'xlsx' library.
 * Each sheet becomes a DocumentPage containing a Markdown table generated by sheetToMarkdownTable.
 */
export class ExcelLoader implements FileLoaderInterface {
  async loadPages(filePath: string): Promise<DocumentPage[]> {
    const pages: DocumentPage[] = [];
    try {
      // Use readFile for async operation compatible with other loaders
      const dataBuffer = await readFile(filePath);
      const workbook = xlsx.read(dataBuffer, { type: 'buffer' });

      for (const sheetName of workbook.SheetNames) {
        const worksheet = workbook.Sheets[sheetName];
        // Use sheet_to_json to get array of objects for our custom markdown function
        const jsonData = xlsx.utils.sheet_to_json<Record<string, any>>(worksheet, {
          // Get formatted strings, not raw values
          defval: '',
          raw: false, // Use empty string for blank cells
        });

        // Convert to markdown using YOUR helper function
        const tableMarkdown = sheetToMarkdownTable(jsonData);

        const lines = tableMarkdown.split('\n');
        const lineCount = lines.length;
        const charCount = tableMarkdown.length;

        pages.push({
          // Trim whitespace
          charCount,
          lineCount,
          metadata: {
            sheetName: sheetName,
          },
          pageContent: tableMarkdown.trim(),
        });
      }

      if (pages.length === 0) {
        pages.push({
          charCount: 0,
          lineCount: 0,
          metadata: {
            error: 'Excel file contains no sheets.',
          },
          pageContent: '',
        });
      }

      return pages;
    } catch (e) {
      const error = e as Error;
      console.error(`Error loading Excel file ${filePath}: ${error.message}`);
      const errorPage: DocumentPage = {
        charCount: 0,
        lineCount: 0,
        metadata: {
          error: `Failed to load Excel file: ${error.message}`,
        },
        pageContent: '',
      };
      return [errorPage];
    }
  }

  /**
   * Aggregates content from Excel sheets (Markdown tables).
   * Adds the sheet name as a header before each table.
   * @param pages Array of DocumentPage objects from loadPages.
   * @returns Aggregated content as a string.
   */
  async aggregateContent(pages: DocumentPage[]): Promise<string> {
    return pages
      .map((page) => {
        const sheetName = page.metadata.sheetName;
        const header = sheetName ? `## Sheet: ${sheetName}\n\n` : '';
        return header + page.pageContent;
      })
      .join('\n\n---\n\n'); // Separator between sheets
  }
}
